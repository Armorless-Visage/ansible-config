# Liam Nolan 2016 - halon

int_if="em0"
ext_if="re0"
ps4_ip="192.168.99.20"
torrents_ip="192.168.99.5"
ipsec_ip="192.168.99.111"
icmp_pass = "{ echoreq, unreach, trace }" 
web_ports = "{ 80, 443, 21, 8080 }"
hi_ports = "{ 1025:65535 }"
lo_ports = "{ 1:1024 }"

# libvirt routed net
virt_net = "10.7.7.0/24"

# Set policy
set skip on lo0
set block-policy drop
set loginterface egress    
set state-policy if-bound 
set ruleset-optimization none 
set limit table-entries 1000000


queue upload on $ext_if bandwidth 	9850K
queue std parent upload bandwidth 	500K 	default # keeping this low as expecting most traffic in other queues
queue top parent upload bandwidth 	4000K 	# second queue/lowdelay/empy ACK 
queue web parent upload bandwidth	2000K 	# ports 80, 443, 21, 8080	
queue dns parent upload bandwidth 	900K 	burst 7000K for 200ms
queue torrents parent upload bandwidth 	500K 	max 5500K qlimit 500
queue ntp parent upload bandwidth 	500K
queue low parent upload bandwidth 	1000K # port 1-1024
queue hi  parent upload bandwidth 	1000K # port 1025-65535
# flow queue
#queue fq on $ext_if flows 8184

                                   ## Policy ##
# default deny
block log all
# allow ssh to router from adm
pass in quick on $int_if inet proto tcp from 192.168.99.9 to $int_if port 22 keep state tag ssh

# tag everything as input to pass through scrub
match in all tag input
anchor scrub_anchor
load anchor scrub_anchor from "/etc/anchor_scrub"

anchor ps4_anchor
load anchor ps4_anchor from "/etc/anchor_ps4"
anchor torrents_anchor
load anchor torrents_anchor from "/etc/anchor_torrents"
pass out quick on $ext_if inet proto {tcp, udp} from $torrents_ip modulate state set queue (torrents, std)

#match in on $int_if inet proto tcp from $int_if:network port www tagged input rdr-to 127.0.0.1 port 8080 

# main NAT rule (check it has input tag for scrub)
match out on egress inet from !(egress:network) to any tagged input nat-to (egress:0)

# allow adm to look at modem
pass out quick on $ext_if inet proto tcp from 192.168.99.9 to 192.168.100.1 port 80 keep state


# Internal
pass in quick on $int_if inet from $int_if:network to !$int_if keep state
pass in quick on $int_if inet proto tcp from $int_if:network to $int_if port {53, 80, 8000} keep state 
pass in quick on $int_if inet proto udp from $int_if:network to $int_if port {123 53 67} keep state
pass in quick on $int_if inet proto icmp from $int_if:network to $int_if icmp-type $icmp_pass keep state
pass in quick on $int_if inet proto icmp from $int_if:network to !$int_if icmp-type $icmp_pass keep state
pass out quick on $int_if to $int_if:network keep state 
# External
pass out on $ext_if inet proto {tcp, udp} to port $lo_ports modulate state set queue (low, top)
pass out on $ext_if inet proto {tcp, udp} to port $hi_ports modulate state set queue (hi, top)
pass out on $ext_if inet proto {tcp, udp} to port 53 modulate state set queue (dns, dns)
pass out on $ext_if inet proto udp to port 123 modulate state set queue (ntp, ntp)
pass out on $ext_if inet proto tcp to port $web_ports modulate state set queue (web, top)
pass out on $ext_if inet proto icmp all icmp-type $icmp_pass keep state set queue (std, top) 
  
